引用就是起别名，必须在声明的时候就指定和哪个变量相同，并且一旦声明之后不可再变成别的变量的别名，拷贝构造函数默认隐藏存在于类中，形式为A (const A &a)，不写拷贝构造函数就是浅拷贝，深拷贝构造函数是和构造函数一样自己重新定义的，里面主要写对堆区变量的再次申请内存处理。

以下情况都会调用拷贝构造函数：
    
    一个对象以值传递的方式传入函数体
    
    一个对象以值传递的方式从函数返回
    
    一个对象需要通过另外一个对象进行初始化。
    
    如果在类中没有显式地声明一个拷贝构造函数，那么，编译器将会自动生成一个默认的拷贝构造函数，该构造函数完成对象之间的位拷贝。位拷贝又称浅拷贝，后面将进行说明。
    
    自定义拷贝构造函数是一种良好的编程风格，它可以阻止编译器形成默认的拷贝构造函数，提高源码效率。
    
    浅拷贝和深拷贝
    
    在某些状况下，类内成员变量需要动态开辟堆内存，如果实行位拷贝，也就是把对象里的值完全复制给另一个对象，如A=B.这时，如果B中有一个成员变量指针已经申请了内存，那A中的那个成员变量也指向同一块内存。这就出现了问题：当B把内存释放了（如：析构），这时A内的指针就是野指针了，出现运行错误。
    
    深拷贝和浅拷贝可以简单理解为：如果一个类拥有资源，当这个类的对象发生复制过程的时候，资源重新分配，这个过程就是深拷贝，反之，没有重新分配资源，就是浅拷贝。下面举个深拷贝的例子。
    
    #include <iostream>
    
    using namespace std;
    
    class CA
    
    {
    
    public:
    
    CA（int b,char* cstr）
    
    {
    
    a=b;
    
    str=new char[b];
    
    strcpy（str,cstr）；
    
    }
    
    CA（const CA& C）
    
    {
    
    a=C.a;
    
    str=new char[a]; //深拷贝
    
    if（str!=0）
    
    strcpy（str,C.str）；
    
    }
    
    void Show（）
    
    {
    
    cout《str《endl;
    
    }
    
    ~CA（）
    
    {
    
    delete str;
    
    }
    
    private:
    
    int a;
    
    char *str;
    
    };
    
    int main（）
    
    {
    
    CA A（10,"Hello!"）；
    
    CA B=A;
    
    B.Show（）；
    
    return 0;
    
    }
    
    深拷贝和浅拷贝的定义可以简单理解成：如果一个类拥有资源（堆，或者是其它系统资源），当这个类的对象发生复制过程的时候，这个过程就可以叫做深拷贝，反之对象存在资源，但复制过程并未复制资源的情况视为浅拷贝。
    
    浅拷贝资源后在释放资源的时候会产生资源归属不清的情况导致程序运行出错。
    
    Test（Test &c_t）是自定义的拷贝构造函数，拷贝构造函数的名称必须与类名称一致，函数的形式参数是本类型的一个引用变量，且必须是引用。
    
    当用一个已经初始化过了的自定义类类型对象去初始化另一个新构造的对象的时候，拷贝构造函数就会被自动调用，如果你没有自定义拷贝构造函数的时候，系统将会提供给一个默认的拷贝构造函数来完成这个过程，上面代码的复制核心语句就是通过Test（Test &c_t）拷贝构造函数内的p1=c_t.p1;语句完成的。